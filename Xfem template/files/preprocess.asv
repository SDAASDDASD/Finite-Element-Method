clc
clear


% read information about the cracks
fid = fopen('GGXYC','r');
nCracks = 1;       % number of cracks
NCP = zeros(nCracks);
for i = 1:nCracks
    NCP(i) = fscanf(fid,'%d\n',1);
    temp = fscanf(fid,'%g,%g\n',[2,NCP]);
    temp = temp';
    xCr(i).coor = temp;
    fclose(fid);
end


%read coordinates of all nodes generated by ABAQUS
fid = fopen('m0XY.prn','r');
node = fscanf(fid,'%d,%g,%g\n',[3,inf]);
node = node';
fclose(fid);


%read element topology of all elements generated by ABAQUS
fid = fopen('m0Top.prn','r');
element = fscanf(fid,'%d,%d,%d,%d,%d\n',[5,inf]);
element = element';
fclose(fid);

numnode = size(node,1);         % number of nodes
numelem = size(element,1);      % number of elements



%不考虑裂纹交叉，假定一个单元最多与一条裂纹相关
type_elem = zeros(size(element,1),size(xCr,2));        % 存放单元类型
elem_crk = zeros(size(element,1),4);                          % 存放裂纹与单元边界交点坐标 或者单元内裂尖点坐标   
 xCr_element = zeros(size(element,1),2);                   % 存放单元内裂纹端点坐标
xTip = zeros(size(element,1),2);                                   % 存放单元内裂尖点坐标
xVertex = zeros(size(element,1),2);                              % 存放单元内裂纹顶点坐标，单元内最多只有一个裂纹顶点
enrich_node = zeros(size(node,1),size(xCr,2));           % 存放结点加强方式
intersec_sides  = zeros(size(element,1),8);                 % 存放单元与裂纹线段相交边的编号,交点坐标及裂纹编号
for kk = 1:size(xCr,2)                                                       % 对所有裂纹循环
    for iel = 1:size(element,1)                                           % 对所有单元循环
        sides = 1;
        sctr = element(iel,2:5);                                                 % 当前单元连接信息
        vv = node(sctr,2:3);                                                      % 当前单元结点坐标
        crk_int = [];
        intes = 0; flag1 = 0; flag2 = 0;
        for kj = 1:size(xCr(kk).coor,1)-1                               % 对裂纹线段循环
            q1 = xCr(kk).coor(kj,:); q2 = xCr(kk).coor(kj+1,:);     % 裂纹线段的两个端点坐标
            sctrl = [sctr sctr(1,1)];
            for iedge = 1:size(sctr,2)                                            % 对单元边界循环
                nnode1 = sctrl(iedge); nnode2 = sctrl(iedge+1);  % 单元边界上的两个结点号
                p1 = node(nnode1,2:3); p2 = node(nnode2,2:3);          % 单元边界上的两个结点坐标
                intersect = segments_int_2d(p1,p2,q1,q2);          % 计算两个线段的交点
                % intersect(1) = 0, 两线段不相交；intersect(1) = 1，两线段相交
                % intersect(2:3) 为交点坐标
                intes = intes + intersect(1);
                if intersect(1) > 0
                    crk_int = [crk_int intersect(2) intersect(3)];
                    flag1 = inhull(xCr(kk).coor(kj,:),vv,[],-1e-8);           % 判断xCr(kk).coor(kj,:)是否在单元内，flag1 = 1，在单元内
                    flag2 = inhull(xCr(kk).coor(kj+1,:),vv,[],-1e-8);       % 判断xCr(kk).coor(kj+1,:)是否在单元内，flag2 = 1，在单元内
                    xCr_element(iel,:) = xCr(kk).coor(kj,:)*flag1 + xCr(kk).coor(kj+1,:)*flag2;
                    intersec_sides(iel,sides) = iedge;
                    intersec_sides(iel,(2*sides+1):(2*sides+2)) = intersect(2:3);
                    intersec_sides(iel,8) = flag1*kj+flag2*(kj+1);
                    sides = sides + 1;
                end
            end
        end
        
        
        %判断单元类型
        if (((intes == 2)&&(flag1 == 0))&&(flag2 == 0))         %贯穿单元
            type_elem(iel,kk) = 1;
            elem_crk(iel,:) = crk_int;                                         %裂纹与单元边界的交点坐标
        end
        if (((flag1 ==1 )||(flag2 == 1))&&(intes == 2))            %含顶点的单元
            type_elem(iel,kk) = 3;
            elem_crk(iel,:) = crk_int;                                          %裂纹与单元边界的交点坐标
            xVertex(iel,:) = xCr_element(iel,:);                          %单元内裂纹顶点坐标
        end
        if (intes == 1)                                                                %裂尖单元
            type_elem(iel,kk) = 2;
            xTip(iel,:) = xCr_element(iel,:);                                %裂尖点坐标
            
            elem_crk(iel,:) = [crk_int xTip(iel,1) xTip(iel,2)];
            intersec_sides(iel,5:6) = xTip(iel,:);
       end
   end
end


%判断结点加强方式
for kk = 1:size(xCr,2)
    for iel = 1:size(element,1)
        sctr = element(iel,2:5);
        if (type_elem(iel,kk) == 1)||(type_elem(iel,kk) == 3)       %贯穿单元
            enrich_node(sctr,kk) = 1;                                              %采用阶跃函数加强
        elseif type_elem(iel,kk) ==2                                              %裂尖单元 
            enrich_node(sctr,kk) = 2;                                               %阶跃函数加强
        end
     end
end


for kk = 1:size(xCr,2)
    for iel = 1:size(element,1)
        sctr = element(iel,2:5);
        if (ismember(2,enrich_node(sctr,kk)) ~= 0)
            intersec_sides(iel,7) = kk;
            intersec_sides(iel,8) = NCP(kk);
        end            
     end
end



%计算结点水平集函数
ls = zeros(numnode,1);
for iel = 1:numelem
    sctr = element(iel,2:5);
    x0 = elem_crk(iel,1); y0 = elem_crk(iel,2);
    x1 = elem_crk(iel,3); y1 = elem_crk(iel,4);
    for i = 1:size(sctr,2)
        x = node(sctr(i),2); y = node(sctr(i),3);
        phi = (y1-y0)*x + (x0-x1)*y +(x1*y0-x0*y1);
        if ls(sctr(i),1) == 0
        ls(sctr(i),1) = phi;
        end
    end
end
 

enrich_node_type = zeros(numnode,1);                                %确定结点最终加强方式
for i = 1:numnode
    enrich_node_type(i) = max(enrich_node(i,:));
end
% TopType : topology type of the element
%           replace each node in element with its enrich type
%           0      not enriched
%           1      heaviside enriched
%           2      crack tip enriched
% TopXTypeX : topology type for enriched element
% TopX : element set of enriched element
% TopNoX : element set of non-enriched element
TopType = element;
TopX = [];
TopNoX = [];
TopXTypeX = [];
for iel = 1 : numelem
    sctr = element(iel,2:5);
    TopType(iel,2:5) = enrich_node_type(sctr,1);
    if (any(enrich_node_type(sctr,1)))
    TopX = [TopX;element(iel,:)];
    TopXTypeX = [TopXTypeX;TopType(iel,:)];
    else
     TopNoX = [TopNoX;element(iel,:)];
    end
end

fid = fopen('TopX','w');
fprintf(fid,'%d,%d,%d,%d,%d\n',TopX');
fclose(fid);

fid = fopen('TopNoX','w');
fprintf(fid,'%d,%d,%d,%d,%d\n',TopNoX');
fclose(fid);

fid = fopen('TopXTypeX','w');
fprintf(fid,'%d,%d,%d,%d,%d\n',TopXTypeX');
fclose(fid);


% node set below are nodes belong to enriched elemnt(heaviside enriched,crack tip enriched and partialy enriched)
% NOT only enriched nodes
% they are used in input file
% SETNodeX2dof : non-enriched node belong to enriched element
% SETNodeX4dof : heaviside enriched
% SETNodeX10dof : crack tip enriched
SETNodeX2dof = [];
SETNodeX4dof = [];
SETNodeX10dof = [];
for i =1:size(TopX,1)
    strc = TopX(i,2:5);
    for j =1:size(strc,2)
        if enrich_node_type(strc(j),1) == 0
            SETNodeX2dof = union(SETNodeX2dof,strc(j));
        elseif enrich_node_type(strc(j),1) == 1
            SETNodeX4dof = union(SETNodeX4dof,strc(j));
        elseif enrich_node_type(strc(j),1) == 2
            SETNodeX10dof = union(SETNodeX10dof,strc(j));
        end
    end
end

fid = fopen('SETNodeX2dof','w');
fprintf(fid,'%d,%d,%d,%d,%d,%d,%d,%d\n',SETNodeX2dof');
fclose(fid);

fid = fopen('SETNodeX4dof','w');
fprintf(fid,'%d,%d,%d,%d,%d,%d,%d,%d\n',SETNodeX4dof');
fclose(fid);

fid = fopen('SETNodeX10dof','w');
fprintf(fid,'%d,%d,%d,%d,%d,%d,%d,%d\n',SETNodeX10dof');
fclose(fid);


maxCP = 10;        % max crack path points of every crack
nelemX = size(TopX,1);   % number of enriched elements
% number of nodes belonged to enriched element
nnodeX = size(SETNodeX2dof,2)+size(SETNodeX4dof,2)+size(SETNodeX10dof,2); 
fid = fopen('GGInfoX','w');
fprintf(fid,'%d,%d,%d,%d',nCracks,maxCP,nelemX,nnodeX);
fclose(fid);



for iel = 1:nelemX
    sctr = TopX(iel,2:5);
    maxp = max(ls(sctr,1));
    if maxp == 0
        maxp = -1;
    end
    for j = 1:size(sctr,2)
        if ls(sctr(j),1) == 0
            ls(sctr(j),1) = maxp;
        end
    end
end
            
% EnodeX : node set of nodes belonged to enriched element
% GGnodeX : column 1      node number
%           column 2      enrich type
%           column 3      value of normal Level set function
EnodeX  = union(SETNodeX2dof,union(SETNodeX4dof,SETNodeX10dof));
GGnodeX = zeros(size(EnodeX,2),3);
GGnodeX(:,1) = EnodeX';
GGnodeX(:,2) = enrich_node_type(EnodeX,1);
GGnodeX(:,3) = ls(EnodeX,:);
fid = fopen('GGnodeX','w');
fprintf(fid,'%d,%d,%g\n',GGnodeX');
fclose(fid);



% GGelemX : essential information of enriched element
%           10 columns ,details refer to UEL
element_type = zeros(numelem,1);                                %确定单元最终加强方式
for i = 1:numelem
    element_type(i) = max(type_elem(i,:));
end
GGelemX = zeros(nelemX,10);
GGelemX(:,1) = TopX(:,1);
for i =1 : nelemX
    if  (element_type(TopX(i,1)) == 2)
        GGelemX(i,2) = 40;
    elseif  (element_type(TopX(i,1)) == 1)||(element_type(TopX(i,1)) == 3)
        if abs(intersec_sides(TopX(i,1),1)-intersec_sides(TopX(i,1),2)) == 2
            GGelemX(i,2) = 4;
        else
            GGelemX(i,2) = 5;
        end
    else
        GGelemX(i,2) = -1;
    end
    GGelemX(i,3:10) = intersec_sides(TopX(i,1),:);   
end

fid = fopen('GGelemX','w');
fprintf(fid,'%d,%d,%d,%d,%g,%g,%g,%g,%d,%d\n',GGelemX');
fclose(fid);


% TopXoverlay : overlay elements 
%      has encreased element number and share the same nodes as enriched element,
%      but have negligible stiffness
%      for plot only ,deformed and undeformed
TopXoverlay = TopX;
TopXoverlay(:,1) = TopX(:,1) +1000;
fid = fopen('TopXoverlay','w');
fprintf(fid,'%d,%d,%d,%d,%d\n',TopXoverlay');
fclose(fid);